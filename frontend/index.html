<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRE Agent - Live Mitigation Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .panel h2 {
            margin-bottom: 15px;
            color: #00ff88;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-healthy { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
        .status-warning { background: #ffaa00; box-shadow: 0 0 10px #ffaa00; }
        .status-critical { background: #ff3366; box-shadow: 0 0 10px #ff3366; }
        .status-mitigating { background: #00aaff; box-shadow: 0 0 10px #00aaff; animation: pulse 0.5s infinite; }

        .log-stream {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }

        .log-entry {
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 4px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .log-info { background: rgba(0, 255, 136, 0.1); border-left: 3px solid #00ff88; }
        .log-warning { background: rgba(255, 170, 0, 0.1); border-left: 3px solid #ffaa00; }
        .log-error { background: rgba(255, 51, 102, 0.1); border-left: 3px solid #ff3366; }
        .log-anomaly { background: rgba(255, 51, 102, 0.2); border-left: 3px solid #ff3366; font-weight: bold; }
        .log-mitigation { background: rgba(0, 170, 255, 0.1); border-left: 3px solid #00aaff; }
        .log-rag { background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107; }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .graph-container {
            height: 100px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .graph-grid {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 1;
        }

        .graph-line {
            stroke: #00ff88;
            stroke-width: 2;
            fill: none;
            filter: drop-shadow(0 0 5px #00ff88);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            background: linear-gradient(45deg, #00ff88, #00aaff);
            border: none;
            color: #000;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }

        button.danger {
            background: linear-gradient(45deg, #ff3366, #ff6b6b);
        }

        button.warning {
            background: linear-gradient(45deg, #ffaa00, #ffcc02);
        }

        button.info {
            background: linear-gradient(45deg, #00aaff, #0099cc);
        }

        .anomaly-presets {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .preset-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .preset-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #ff3366;
        }

        .preset-description {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 15px;
        }

        .agent-activity {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .reasoning-trace {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #4a90e2;
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            min-height: 120px;
            position: relative;
            overflow: hidden;
        }

        .reasoning-trace::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #4a90e2, #50c878, #ff6b6b);
            animation: pulse 2s infinite;
        }

        .trace-status {
            color: #b0b0b0;
            font-style: italic;
            text-align: center;
            margin-top: 20px;
        }

        .trace-step {
            background: rgba(74, 144, 226, 0.1);
            border-left: 4px solid #4a90e2;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            animation: slideIn 0.5s ease-out;
        }

        .trace-step.critical {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .trace-step.success {
            border-left-color: #50c878;
            background: rgba(80, 200, 120, 0.1);
        }

        .trace-step.warning {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .agent-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .agent-card.active {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
        }

        .agent-card.anomaly-detected {
            border-color: #ff3366;
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.3);
            animation: pulse 0.5s infinite;
        }

        .agent-name {
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
        }

        .agent-status {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .agent-status.anomaly-detected {
            color: #ff3366;
            font-weight: bold;
        }

        .agent-status.rag-thinking {
            color: #ffc107;
            font-weight: bold;
        }

        .agent-status.mitigating {
            color: #00aaff;
            font-weight: bold;
        }

        .agent-status.escalating {
            color: #ffaa00;
            font-weight: bold;
        }

        .connection-status {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
        }

        .connection-status.connected {
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
        }

        .connection-status.disconnected {
            background: rgba(255, 51, 102, 0.1);
            color: #ff3366;
        }

        .detection-alerts {
            max-height: 200px;
            overflow-y: auto;
        }

        .detection-alert {
            background: rgba(255, 51, 102, 0.1);
            border-left: 3px solid #ff3366;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            animation: slideIn 0.3s ease-out;
        }

        .rag-knowledge {
            max-height: 200px;
            overflow-y: auto;
        }

        .knowledge-entry {
            background: rgba(255, 193, 7, 0.1);
            border-left: 3px solid #ffc107;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }

        .knowledge-title {
            font-weight: bold;
            color: #ffc107;
            margin-bottom: 5px;
        }

        .knowledge-solution {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .mitigation-actions {
            max-height: 200px;
            overflow-y: auto;
        }

        .mitigation-entry {
            background: rgba(0, 170, 255, 0.1);
            border-left: 3px solid #00aaff;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mitigation-info {
            flex: 1;
        }

        .mitigation-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .status-pending { background: rgba(255, 170, 0, 0.2); color: #ffaa00; }
        .status-success { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .status-failed { background: rgba(255, 51, 102, 0.2); color: #ff3366; }

        .thought-process {
            background: rgba(255, 193, 7, 0.05);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .thought-process h4 {
            color: #ffc107;
            margin-bottom: 10px;
        }

        .thought-step {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .validation-results {
            background: rgba(0, 170, 255, 0.05);
            border: 1px solid rgba(0, 170, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .validation-results h4 {
            color: #00aaff;
            margin-bottom: 10px;
        }

        .metric-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .metric-before, .metric-after {
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .metric-before {
            background: rgba(255, 51, 102, 0.1);
            border: 1px solid rgba(255, 51, 102, 0.3);
        }

        .metric-after {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ SRE Agent - Live Mitigation System</h1>
        <div class="connection-status" id="connectionStatus">
            <span id="connectionText">Connecting to SRE Agent System...</span>
        </div>
        
        <div class="grid">
            <!-- System Status -->
            <div class="panel">
                <h2>
                    <span class="status-indicator" id="systemStatus"></span>
                    System Status
                </h2>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="logsProcessed">0</div>
                        <div class="metric-label">Logs Processed</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="anomaliesDetected">0</div>
                        <div class="metric-label">Anomalies</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="autoResolved">0</div>
                        <div class="metric-label">Auto-Resolved</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="pagesSent">0</div>
                        <div class="metric-label">Pages Sent</div>
                    </div>
                </div>
                <div class="graph-container">
                    <svg width="100%" height="100%" id="performanceGraph">
                        <line x1="0" y1="50%" x2="100%" y2="50%" class="graph-grid"/>
                        <polyline id="graphLine" class="graph-line" points=""/>
                    </svg>
                </div>
            </div>

            <!-- Live Log Stream -->
            <div class="panel">
                <h2>üìä Live Log Stream</h2>
                <div class="log-stream" id="logStream"></div>
                <div class="action-buttons">
                    <button onclick="refreshData()">Refresh Data</button>
                    <button onclick="clearLogs()">Clear Logs</button>
                    <button onclick="toggleAutoRefresh()" id="autoRefreshBtn">Auto Refresh: ON</button>
                </div>
            </div>
        </div>

        <!-- Anomaly Simulation Panel -->
        <div class="panel full-width">
            <h2>üö® Anomaly Simulation</h2>
            <p style="margin-bottom: 15px; opacity: 0.8;">Trigger preset anomalies to test the complete SRE Agent flow:</p>
            <div class="anomaly-presets">
                <div class="preset-card">
                    <div class="preset-title">üî• CPU Overload</div>
                    <div class="preset-description">Simulate high CPU usage (95%+) across multiple services</div>
                    <button class="danger" onclick="triggerAnomaly('cpu_overload')">Trigger CPU Overload</button>
                </div>
                <div class="preset-card">
                    <div class="preset-title">üíæ Memory Leak</div>
                    <div class="preset-description">Simulate memory usage spike and garbage collection issues</div>
                    <button class="danger" onclick="triggerAnomaly('memory_leak')">Trigger Memory Leak</button>
                </div>
                <div class="preset-card">
                    <div class="preset-title">üêå Database Slowdown</div>
                    <div class="preset-description">Simulate slow database queries and connection pool exhaustion</div>
                    <button class="warning" onclick="triggerAnomaly('database_slowdown')">Trigger DB Slowdown</button>
                </div>
                <div class="preset-card">
                    <div class="preset-title">üåê Network Latency</div>
                    <div class="preset-description">Simulate high network latency and timeout errors</div>
                    <button class="warning" onclick="triggerAnomaly('network_latency')">Trigger Network Issues</button>
                </div>
                <div class="preset-card">
                    <div class="preset-title">üí• Service Crash</div>
                    <div class="preset-description">Simulate critical service failure (goes to Advanced LLM)</div>
                    <button class="danger" onclick="triggerAnomaly('service_crash')">Trigger Service Crash</button>
                </div>
                <div class="preset-card">
                    <div class="preset-title">üîÑ Reset System</div>
                    <div class="preset-description">Reset all anomalies and return to normal operation</div>
                    <button onclick="resetSystem()">Reset to Normal</button>
                </div>
            </div>
        </div>

        

        <!-- Agent Activity Panel -->
        <div class="panel full-width">
            <h2>ü§ñ Agent Activity</h2>
            <div class="agent-activity" id="agentActivity">
                <div class="agent-card" id="anomalyDetector">
                    <div class="agent-name">Anomaly Detector</div>
                    <div class="agent-status">Idle</div>
                </div>
                <div class="agent-card" id="ragAgent">
                    <div class="agent-name">RAG Agent</div>
                    <div class="agent-status">Idle</div>
                </div>
                <div class="agent-card" id="mitigationAgent">
                    <div class="agent-name">Mitigation Agent</div>
                    <div class="agent-status">Idle</div>
                </div>
                <div class="agent-card" id="advancedLLM">
                    <div class="agent-name">Critical Anomaly Reasoning Agent</div>
                    <div class="agent-status">Idle</div>
                </div>
                <div class="agent-card" id="pagingAgent">
                    <div class="agent-name">Paging Agent</div>
                    <div class="agent-status">Idle</div>
                </div>
            </div>
        </div>

        <!-- Reasoning Trace Panel -->
        <div class="panel full-width">
            <h2>üß† Reasoning Trace</h2>
            <div id="reasoningTrace" class="reasoning-trace">
                <div class="trace-status">Waiting for anomaly detection...</div>
            </div>
        </div>

        <!-- RAG Agent Thoughts Panel -->
        <div class="panel full-width">
            <h2>üß† RAG Agent Analysis</h2>
            <div id="ragThoughts" class="thought-process" style="display: none;">
                <h4>ü§î RAG Agent Thought Process</h4>
                <div id="thoughtSteps"></div>
            </div>
            <div id="ragKnowledge" class="rag-knowledge"></div>
        </div>

        <!-- Mitigation Execution Panel -->
        <div class="panel full-width">
            <h2>‚ö° Mitigation Execution</h2>
            <div id="validationResults" class="validation-results" style="display: none;">
                <h4>üìä Action Validation Results</h4>
                <div id="metricComparison"></div>
                <div id="sideEffects"></div>
            </div>
            <div id="mitigationActions" class="mitigation-actions"></div>
        </div>

        <!-- Agent Decision Log -->
        <div class="panel full-width">
            <h2>üìù Agent Decision Log</h2>
            <div class="log-stream" id="decisionLog"></div>
        </div>
    </div>

    <script>
        class SREDashboard {
            constructor() {
                this.apiBase = '/api';
                this.autoRefresh = true;
                this.refreshInterval = null;
                this.lastLogCount = 0;
                this.lastAnomalyCount = 0;
                this.agentStates = {};
                this.graphData = [];
                this.mitigationHistory = [];
                this.activeAnomalies = [];
                this.ragKnowledgeBase = {
                    cpu_overload: {
                        title: "CPU Overload",
                        priority: "high",
                        solutions: [
                            "Scale up service instances",
                            "Clear application cache",
                            "Kill high-CPU processes"
                        ]
                    },
                    memory_leak: {
                        title: "Memory Leak",
                        priority: "high",
                        solutions: [
                            "Restart affected service",
                            "Clear memory cache",
                            "Scale horizontally"
                        ]
                    },
                    database_slowdown: {
                        title: "Database Slowdown",
                        priority: "medium",
                        solutions: [
                            "Optimize database configuration",
                            "Clear query cache",
                            "Increase connection pool"
                        ]
                    },
                    network_latency: {
                        title: "Network Latency",
                        priority: "medium",
                        solutions: [
                            "Increase timeout values",
                            "Add load balancer instances",
                            "Enable circuit breaker"
                        ]
                    },
                    service_crash: {
                        title: "Service Crash",
                        priority: "critical",
                        solutions: [
                            "Immediate service restart",
                            "Rollback to stable version",
                            "Failover to backup"
                        ]
                    }
                };
                
                // Initialize dashboard
                this.testConnection();
                this.loadInitialData();
                this.startContinuousUpdates();
            }

            startContinuousUpdates() {
                // Update metrics every 5 seconds
                setInterval(() => {
                    this.refreshData();
                }, 5000);
                
                // Update anomaly detector status continuously
                setInterval(() => {
                    this.updateAnomalyDetectorStatus();
                }, 2000);
            }

            updateAnomalyDetectorStatus() {
                const anomalyDetector = document.querySelector('.agent-card[data-agent="anomalyDetector"] .agent-status');
                if (anomalyDetector) {
                    // Fetch real detection status
                    fetch('/api/anomaly-detection/status')
                        .then(response => response.json())
                        .then(data => {
                            if (data.is_anomaly && data.model_used === 'ML Model') {
                                const confidence = (data.confidence * 100).toFixed(1);
                                anomalyDetector.textContent = `Anomaly Detected (${confidence}% confidence)`;
                                anomalyDetector.className = 'agent-status status-anomaly-detected';
                                
                                // Show ML model info
                                console.log('üß† ML Model detected anomaly:', data.ml_explanation);
                            } else if (data.model_used === 'Synthetic Normal') {
                                // Synthetic log - show normal status
                                anomalyDetector.textContent = 'Analyzing synthetic logs...';
                                anomalyDetector.className = 'agent-status status-analyzing';
                            } else {
                                anomalyDetector.textContent = 'Anomaly not detected';
                                anomalyDetector.className = 'agent-status status-normal';
                            }
                        })
                        .catch(error => {
                            // Fallback to continuous analysis status
                            const statuses = [
                                'Running inference...',
                                'Analyzing metrics...',
                                'Processing logs...',
                                'Evaluating patterns...',
                                'Checking thresholds...'
                            ];
                            
                            const randomStatus = statuses[Math.floor(Math.random() * statuses.length)];
                            anomalyDetector.textContent = randomStatus;
                            anomalyDetector.className = 'agent-status status-analyzing';
                        });
                }
            }

            async init() {
                await this.testConnection();
                await this.loadInitialData();
                this.startRealTimeUpdates();
            }

            async testConnection() {
                try {
                    const response = await fetch(`${this.apiBase}/health`);
                    if (response.ok) {
                        this.updateConnectionStatus('Connected to SRE Agent System', 'connected');
                    } else {
                        this.updateConnectionStatus('SRE Agent System unavailable', 'disconnected');
                    }
                } catch (error) {
                    this.updateConnectionStatus('Connection failed', 'disconnected');
                }
            }

            async loadInitialData() {
                try {
                    const metrics = await this.fetchMetrics();
                    this.updateMetrics(metrics);
                } catch (error) {
                    console.error('Failed to load initial data:', error);
                }
            }

            startRealTimeUpdates() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
                
                this.refreshInterval = setInterval(() => {
                    if (this.autoRefresh) {
                        this.refreshData();
                    }
                }, 5000);
            }

            async refreshData() {
                try {
                    const metrics = await this.fetchMetrics();
                    this.updateMetrics(metrics);
                    
                    const agentData = await this.fetchAgentStatus();
                    this.updateAgentStatus(agentData);
                    
                    // Fetch recent logs from the new API
                    const logsData = await this.fetchRecentLogs();
                    this.updateLogStream(logsData);
                    
                    // Update graph with log count
                    this.updateGraph(logsData.total);
                } catch (error) {
                    console.error('Failed to refresh data:', error);
                }
            }

            async fetchMetrics() {
                const response = await fetch(`${this.apiBase}/dashboard/metrics`);
                if (!response.ok) throw new Error('Failed to fetch metrics');
                return await response.json();
            }

            async fetchAgentStatus() {
                const response = await fetch(`${this.apiBase}/agents/status`);
                if (!response.ok) throw new Error('Failed to fetch agent status');
                return await response.json();
            }

            async fetchRecentLogs() {
                const response = await fetch(`${this.apiBase}/logs/recent`);
                if (!response.ok) throw new Error('Failed to fetch recent logs');
                return await response.json();
            }

            updateMetrics(metrics) {
                document.getElementById('logsProcessed').textContent = metrics.logsProcessed.toLocaleString();
                document.getElementById('anomaliesDetected').textContent = metrics.anomaliesDetected;
                document.getElementById('autoResolved').textContent = metrics.autoResolved;
                document.getElementById('pagesSent').textContent = metrics.pagesSent;
                
                // Update system status based on metrics
                this.updateSystemStatus(metrics.systemStatus);
            }

            updateSystemStatus(status = 'healthy') {
                const indicator = document.getElementById('systemStatus');
                indicator.className = `status-indicator status-${status}`;
            }

            updateAgentStatus(agentData) {
                agentData.agents.forEach(agent => {
                    const agentCard = document.getElementById(agent.name.toLowerCase().replace(/\s+/g, ''));
                    if (agentCard) {
                        const statusDiv = agentCard.querySelector('.agent-status');
                        statusDiv.textContent = agent.status;
                        
                        if (agent.status === 'online') {
                            agentCard.classList.add('active');
                        } else {
                            agentCard.classList.remove('active');
                        }
                    }
                });
            }

            updateLogStream(logsData) {
                const logStream = document.getElementById('logStream');
                logStream.innerHTML = '';
                
                // Add logs to the stream
                logsData.logs.forEach(log => {
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry';
                    
                    // Format timestamp
                    const timestamp = new Date(log.timestamp).toLocaleTimeString();
                    
                    // Create log message
                    let message = `[${timestamp}] ${log.service}: ${log.message}`;
                    
                    // Only show anomaly styling for triggered anomalies (req_test_)
                    if (log.anomaly && log.request_id && log.request_id.includes('req_test_')) {
                        message = `üö® ${message}`;
                        logEntry.className += ' log-anomaly'; // Red for anomalies
                    } else {
                        // All non-anomaly logs are green
                        logEntry.className += ' log-info';
                    }
                    
                    logEntry.textContent = message;
                    logStream.appendChild(logEntry);
                });
                
                // Keep only last 20 logs visible
                while (logStream.children.length > 20) {
                    logStream.removeChild(logStream.firstChild);
                }
            }

            updateGraph(logCount) {
                this.graphData.push(logCount);
                if (this.graphData.length > 50) {
                    this.graphData.shift();
                }
                
                const svg = document.getElementById('performanceGraph');
                const width = svg.clientWidth;
                const height = svg.clientHeight;
                
                if (this.graphData.length > 1) {
                    const maxValue = Math.max(...this.graphData);
                    const minValue = Math.min(...this.graphData);
                    const range = maxValue - minValue || 1;
                    
                    const points = this.graphData.map((value, index) => {
                        const x = (index / (this.graphData.length - 1)) * width;
                        const y = height - ((value - minValue) / range) * height;
                        return `${x},${y}`;
                    }).join(' ');
                    
                    document.getElementById('graphLine').setAttribute('points', points);
                }
            }

            async triggerAnomaly(anomalyType) {
                try {
                    // Call the API to trigger anomaly
                    const response = await fetch(`${this.apiBase}/trigger-anomaly`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ type: anomalyType })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to trigger anomaly');
                    }
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Add to active anomalies
                        const anomaly = this.ragKnowledgeBase[anomalyType];
                        if (anomaly) {
                            const anomalyId = Date.now();
                            this.activeAnomalies.push({
                                id: anomalyId,
                                type: anomalyType,
                                title: anomaly.title,
                                priority: anomaly.priority,
                                timestamp: new Date().toISOString()
                            });
                        }
                        
                        // Log the anomaly
                        this.addLog('ANOMALY', `üö® ${anomalyType} anomaly triggered!`);
                        this.addDecision(`Anomaly Detector: ${anomalyType} identified with high confidence`);
                        
                        // Start the complete flow
                        this.startCompleteFlow(anomalyType, anomaly || { title: anomalyType, priority: 'high' });
                        
                        // Update system status
                        this.updateSystemStatus();
                        
                        // Refresh data to show updated metrics
                        setTimeout(() => this.refreshData(), 1000);
                    } else {
                        console.error('Failed to trigger anomaly:', result.error);
                    }
                } catch (error) {
                    console.error('Error triggering anomaly:', error);
                }
            }

            startCompleteFlow(anomalyType, anomaly) {
                // Clear previous reasoning trace
                this.clearReasoningTrace();
                
                // Determine if this is a critical issue (service crash)
                const isCritical = anomalyType === 'service_crash';
                
                // Step 1: Anomaly Detector (5 seconds)
                this.addReasoningStep('üîç Anomaly Detector: Starting inference analysis...', 'info');
                this.activateAgent('anomalyDetector', 'Running inference...', 'anomaly-detected');
                
                setTimeout(() => {
                    this.activateAgent('anomalyDetector', 'Anomaly Detected', 'anomaly-detected');
                    this.addReasoningStep('‚úÖ Anomaly Detector: Critical anomaly detected in system', 'critical');
                    
                    // Step 2: RAG Agent (5 seconds)
                    setTimeout(() => {
                        this.addReasoningStep('üß† RAG Agent: Initializing knowledge base analysis...', 'info');
                        this.activateAgent('ragAgent', 'Initializing RAG analysis...', 'rag-thinking');
                        
                        setTimeout(() => {
                            this.activateAgent('ragAgent', 'Querying knowledge base...', 'rag-thinking');
                            
                            setTimeout(() => {
                                this.activateAgent('ragAgent', 'Parsing LLM results...', 'rag-thinking');
                                
                                setTimeout(() => {
                                    this.activateAgent('ragAgent', 'Analyzing anomaly...', 'rag-thinking');
                                    this.showRAGThoughts(anomalyType, anomaly);
                                    
                                    if (isCritical) {
                                        this.addReasoningStep('‚ö†Ô∏è RAG Agent: No suitable playbook found - escalating to Critical Anomaly Reasoning Agent', 'warning');
                                        
                                        // Step 3: Critical Anomaly Reasoning Agent (5 seconds)
                                        setTimeout(() => {
                                            this.addReasoningStep('üß† Critical Anomaly Reasoning Agent: Analyzing complex failure patterns...', 'info');
                                            this.activateAgent('advancedLLM', 'Analyzing complex failure...', 'escalating');
                                            
                                            setTimeout(() => {
                                                this.activateAgent('advancedLLM', 'Generating comprehensive analysis...', 'escalating');
                                                
                                                setTimeout(() => {
                                                    this.activateAgent('advancedLLM', 'Creating mitigation plan...', 'escalating');
                                                    this.escalateToAdvancedLLM(anomaly);
                                                    this.addReasoningStep('üìã Critical Anomaly Reasoning Agent: Generated comprehensive analysis and mitigation plan', 'success');
                                                    
                                                    // Step 4: Paging Agent (5 seconds) - This is where report and paging happen
                                                    setTimeout(() => {
                                                        this.addReasoningStep('üìû Paging Agent: Initiating critical alert sequence...', 'info');
                                                        this.activateAgent('pagingAgent', 'Preparing alert...', 'escalating');
                                                        
                                                        setTimeout(() => {
                                                            this.activateAgent('pagingAgent', 'Generating critical SRE report...', 'escalating');
                                                            this.addReasoningStep('üìß Report Generation: Generating critical SRE report...', 'info');
                                                            
                                                            setTimeout(() => {
                                                                this.activateAgent('pagingAgent', 'Sending email to assigned SRE...', 'escalating');
                                                                this.addReasoningStep('üìß Report Generation: Sending email to assigned SRE (xaviers3601@gmail.com)', 'success');
                                                                
                                                                setTimeout(() => {
                                                                    this.activateAgent('pagingAgent', 'Paging SRE for critical issue...', 'escalating');
                                                                    this.addReasoningStep('üìû Paging Agent: Paging SRE for critical issue (+18573357165)', 'critical');
                                                                    
                                                                    // Actually trigger the report and paging here
                                                                    this.triggerReportAndPaging(anomaly);
                                                                    
                                                                    setTimeout(() => {
                                                                        this.addReasoningStep('‚úÖ CRITICAL INCIDENT FLOW COMPLETE: Human intervention required', 'critical');
                                                                    }, 1000);
                                                                }, 1000);
                                                            }, 1000);
                                                        }, 1000);
                                                    }, 1000);
                                                }, 1000);
                                            }, 1000);
                                        }, 1000);
                                    } else {
                                        // Non-critical issues: RAG found solution
                                        this.addReasoningStep('‚úÖ RAG Agent: Found suitable playbook - proceeding to mitigation', 'success');
                                        
                                        // Step 3: Mitigation Agent (10 seconds)
                                        setTimeout(() => {
                                            this.addReasoningStep('‚ö° Mitigation Agent: Preparing automated solution...', 'info');
                                            this.activateAgent('mitigationAgent', 'Preparing mitigation...', 'mitigating');
                                            
                                            setTimeout(() => {
                                                this.activateAgent('mitigationAgent', 'Implementing solution...', 'mitigating');
                                                this.executeMitigation(anomalyType, anomaly);
                                                this.addReasoningStep('üîß Mitigation Agent: Implementing automated solution...', 'info');
                                                
                                                setTimeout(() => {
                                                    this.activateAgent('mitigationAgent', 'Validating results...', 'mitigating');
                                                    
                                                    setTimeout(() => {
                                                        this.activateAgent('mitigationAgent', 'Solution deployed', 'mitigating');
                                                        this.addReasoningStep('‚úÖ Mitigation Agent: Solution successfully deployed and validated', 'success');
                                                        this.addReasoningStep('‚úÖ STANDARD INCIDENT FLOW COMPLETE: Issue resolved automatically', 'success');
                                                    }, 1000);
                                                }, 5000);
                                            }, 5000);
                                        }, 1000);
                                    }
                                }, 1000);
                            }, 1000);
                        }, 1000);
                    }, 5000);
                }, 5000);
            }

            showRAGThoughts(anomalyType, anomaly) {
                const thoughtsDiv = document.getElementById('ragThoughts');
                const stepsDiv = document.getElementById('thoughtSteps');
                
                if (anomalyType === 'service_crash') {
                    // Service crash - no playbook found
                    const thoughts = [
                        `Analyzing ${anomaly.title} pattern...`,
                        `Checking knowledge base for similar issues...`,
                        `No suitable playbook found for service crash`,
                        `Service crash requires complex analysis`,
                        `Escalating to Advanced LLM for comprehensive solution...`
                    ];
                    
                    stepsDiv.innerHTML = thoughts.map(thought => 
                        `<div class="thought-step">${thought}</div>`
                    ).join('');
                    
                    thoughtsDiv.style.display = 'block';
                    
                    this.addDecision(`RAG Agent: No playbook found for service crash - escalating to Advanced LLM`);
                    
                    // Show escalation message
                    const knowledgeContainer = document.getElementById('ragKnowledge');
                    knowledgeContainer.innerHTML = '';
                    
                    const escalationDiv = document.createElement('div');
                    escalationDiv.className = 'knowledge-entry';
                    escalationDiv.innerHTML = `
                        <div class="knowledge-title">üö® Service Crash - Escalation Required</div>
                        <div class="knowledge-solution">
                            <strong>RAG Agent cannot handle service crash:</strong><br>
                            ‚Ä¢ No pre-defined playbook available<br>
                            ‚Ä¢ Requires complex failure analysis<br>
                            ‚Ä¢ Escalating to Advanced LLM for comprehensive solution<br>
                            ‚Ä¢ Human intervention may be required
                        </div>
                    `;
                    
                    knowledgeContainer.appendChild(escalationDiv);
                } else {
                    // Normal RAG processing
                    const thoughts = [
                        `Analyzing ${anomaly.title} pattern...`,
                        `Checking knowledge base for similar issues...`,
                        `Found ${anomaly.solutions.length} potential solutions`,
                        `Evaluating risk levels and success rates...`,
                        `Selecting optimal mitigation strategy...`
                    ];
                    
                    stepsDiv.innerHTML = thoughts.map(thought => 
                        `<div class="thought-step">${thought}</div>`
                    ).join('');
                    
                    thoughtsDiv.style.display = 'block';
                    
                    this.addDecision(`RAG Agent: Analyzing ${anomaly.title} with ${anomaly.solutions.length} potential solutions`);
                    
                    // Show RAG knowledge
                    this.displayRAGKnowledge(anomaly);
                }
            }

            displayRAGKnowledge(anomaly) {
                const knowledgeContainer = document.getElementById('ragKnowledge');
                knowledgeContainer.innerHTML = '';
                
                const knowledgeDiv = document.createElement('div');
                knowledgeDiv.className = 'knowledge-entry';
                knowledgeDiv.innerHTML = `
                    <div class="knowledge-title">${anomaly.title}</div>
                    <div class="knowledge-solution">
                        <strong>RAG Agent found ${anomaly.solutions.length} solutions:</strong><br>
                        ${anomaly.solutions.map((solution, index) => `${index + 1}. ${solution}`).join('<br>')}
                    </div>
                `;
                
                knowledgeContainer.appendChild(knowledgeDiv);
                this.addDecision(`RAG Agent: Retrieved ${anomaly.solutions.length} mitigation strategies from knowledge base`);
            }

            executeMitigation(anomalyType, anomaly) {
                const solutions = anomaly.solutions;
                const selectedSolution = solutions[Math.floor(Math.random() * solutions.length)];
                
                const mitigationId = Date.now();
                const mitigationEntry = {
                    id: mitigationId,
                    anomaly: anomaly.title,
                    action: selectedSolution,
                    status: 'pending',
                    timestamp: new Date().toISOString()
                };
                
                this.mitigationHistory.push(mitigationEntry);
                this.displayMitigation(mitigationEntry);
                
                // Log the mitigation action
                this.addLog('MITIGATION', `Mitigation Agent executing: ${selectedSolution}`);
                this.addDecision(`Mitigation Agent: Selected strategy - ${selectedSolution}`);
                
                // Show validation results
                setTimeout(() => {
                    this.showValidationResults(anomalyType, anomaly);
                }, 1000);
                
                // Simulate mitigation execution
                setTimeout(() => {
                    const success = Math.random() > 0.2; // 80% success rate
                    
                    if (success) {
                        mitigationEntry.status = 'success';
                        this.resolveAnomaly(anomalyType);
                        this.addLog('INFO', `‚úÖ Mitigation successful: ${selectedSolution}`);
                        this.addDecision(`Mitigation Agent: Action completed successfully. System recovering.`);
                    } else {
                        mitigationEntry.status = 'failed';
                        this.addLog('ERROR', `‚úó Mitigation failed: ${selectedSolution}`);
                        this.addDecision(`Mitigation Agent: Action failed. Escalating to Advanced LLM.`);
                        
                        // Escalate to Advanced LLM
                        setTimeout(() => {
                            this.activateAgent('advancedLLM', 'Analyzing failure...', 'escalating');
                            this.addDecision('Advanced LLM: Taking over failed mitigation scenario');
                        }, 1000);
                    }
                    
                    this.updateMitigationStatus(mitigationId, mitigationEntry.status);
                }, 2000 + Math.random() * 3000);
            }

            showValidationResults(anomalyType, anomaly) {
                const validationDiv = document.getElementById('validationResults');
                const comparisonDiv = document.getElementById('metricComparison');
                const effectsDiv = document.getElementById('sideEffects');
                
                // Simulate metrics before/after
                const beforeMetrics = {
                    cpu_usage: 95.5,
                    memory_usage: 87.2,
                    error_rate: 0.15,
                    request_latency_ms: 5000
                };
                
                const afterMetrics = {
                    cpu_usage: 45.2,
                    memory_usage: 52.1,
                    error_rate: 0.02,
                    request_latency_ms: 120
                };
                
                comparisonDiv.innerHTML = `
                    <div class="metric-before">
                        <strong>Before Mitigation</strong><br>
                        CPU: ${beforeMetrics.cpu_usage}%<br>
                        Memory: ${beforeMetrics.memory_usage}%<br>
                        Error Rate: ${(beforeMetrics.error_rate * 100).toFixed(1)}%<br>
                        Latency: ${beforeMetrics.request_latency_ms}ms
                    </div>
                    <div class="metric-after">
                        <strong>After Mitigation</strong><br>
                        CPU: ${afterMetrics.cpu_usage}%<br>
                        Memory: ${afterMetrics.memory_usage}%<br>
                        Error Rate: ${(afterMetrics.error_rate * 100).toFixed(1)}%<br>
                        Latency: ${afterMetrics.request_latency_ms}ms
                    </div>
                `;
                
                effectsDiv.innerHTML = `
                    <strong>Side Effects:</strong> Temporary service restart (30s downtime)<br>
                    <strong>Improvement:</strong> 52.7% overall improvement<br>
                    <strong>Time to Effect:</strong> 45 seconds
                `;
                
                validationDiv.style.display = 'block';
            }

            escalateToAdvancedLLM(anomaly) {
                this.addLog('ESCALATION', `Advanced LLM analyzing complex ${anomaly.title}`);
                this.addDecision(`Advanced LLM: Service crash detected - performing deep analysis`);
                
                setTimeout(() => {
                    this.addDecision(`Advanced LLM: Root cause identified - cascading failure pattern`);
                    this.addDecision(`Advanced LLM: Recommending immediate rollback and failover`);
                    
                    // Show Advanced LLM analysis
                    const validationDiv = document.getElementById('validationResults');
                    validationDiv.style.display = 'block';
                    
                    const comparisonDiv = document.getElementById('metricComparison');
                    comparisonDiv.innerHTML = `
                        <div class="metric-before">
                            <strong>Service Crash Analysis</strong><br>
                            ‚Ä¢ Critical service failure<br>
                            ‚Ä¢ Cascading error pattern<br>
                            ‚Ä¢ High error rate: 25%<br>
                            ‚Ä¢ System instability
                        </div>
                        <div class="metric-after">
                            <strong>Recommended Actions</strong><br>
                            ‚Ä¢ Immediate service restart<br>
                            ‚Ä¢ Rollback to stable version<br>
                            ‚Ä¢ Failover to backup<br>
                            ‚Ä¢ Human intervention required
                        </div>
                    `;
                    
                    const effectsDiv = document.getElementById('sideEffects');
                    effectsDiv.innerHTML = `
                        <strong>Advanced LLM Analysis Summary:</strong><br>
                        ‚Ä¢ Root Cause: Memory corruption leading to service crash<br>
                        ‚Ä¢ Impact: Critical service unavailable<br>
                        ‚Ä¢ Recommended: Immediate rollback + human review<br>
                        ‚Ä¢ Estimated Resolution Time: 15-30 minutes<br>
                        ‚Ä¢ Risk Level: HIGH - requires human intervention
                    `;
                    
                    // Activate paging agent
                    setTimeout(() => {
                        this.activateAgent('pagingAgent', 'Paging human...', 'escalating');
                        this.addLog('PAGING', `üö® Human escalation required for ${anomaly.title}`);
                        this.addDecision(`Paging Agent: Alerting on-call engineer for manual intervention`);
                        
                        // Show paging details
                        const mitigationContainer = document.getElementById('mitigationActions');
                        const pagingDiv = document.createElement('div');
                        pagingDiv.className = 'mitigation-entry';
                        pagingDiv.innerHTML = `
                            <div class="mitigation-info">
                                <strong>üö® HUMAN ESCALATION</strong><br>
                                <small>Service crash requires immediate human intervention</small>
                            </div>
                            <div class="mitigation-status status-pending">PAGING SENT</div>
                        `;
                        
                        mitigationContainer.insertBefore(pagingDiv, mitigationContainer.firstChild);
                    }, 2000);
                }, 3000);
            }

            resolveAnomaly(anomalyType) {
                this.activeAnomalies = this.activeAnomalies.filter(a => a.type !== anomalyType);
                this.updateSystemStatus();
                
                // Reset agent states
                setTimeout(() => {
                    this.activateAgent('anomalyDetector', 'Idle');
                    this.activateAgent('ragAgent', 'Idle');
                    this.activateAgent('mitigationAgent', 'Idle');
                    this.activateAgent('advancedLLM', 'Idle');
                    this.activateAgent('pagingAgent', 'Idle');
                }, 2000);
            }

            activateAgent(agentId, action, statusClass = '') {
                const agentCard = document.getElementById(agentId);
                if (agentCard) {
                    const statusDiv = agentCard.querySelector('.agent-status');
                    statusDiv.textContent = action;
                    
                    // Remove all status classes
                    agentCard.classList.remove('active', 'anomaly-detected');
                    statusDiv.classList.remove('anomaly-detected', 'rag-thinking', 'mitigating', 'escalating');
                    
                    // Add appropriate classes
                    if (statusClass) {
                        agentCard.classList.add('active');
                        statusDiv.classList.add(statusClass);
                    }
                }
            }

            displayMitigation(entry) {
                const container = document.getElementById('mitigationActions');
                const entryDiv = document.createElement('div');
                entryDiv.className = 'mitigation-entry';
                entryDiv.id = `mitigation-${entry.id}`;
                entryDiv.innerHTML = `
                    <div class="mitigation-info">
                        <strong>${entry.anomaly}</strong><br>
                        <small>${entry.action}</small>
                    </div>
                    <div class="mitigation-status status-${entry.status}">${entry.status.toUpperCase()}</div>
                `;
                
                container.insertBefore(entryDiv, container.firstChild);
                
                if (container.children.length > 5) {
                    container.removeChild(container.lastChild);
                }
            }

            updateMitigationStatus(id, status) {
                const entry = document.querySelector(`#mitigation-${id} .mitigation-status`);
                if (entry) {
                    entry.className = `mitigation-status status-${status}`;
                    entry.textContent = status.toUpperCase();
                }
            }

            addLog(level, message) {
                const logStream = document.getElementById('logStream');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${level.toLowerCase()}`;
                logEntry.textContent = `[${new Date().toISOString().split('T')[1].split('.')[0]}] ${message}`;
                
                logStream.insertBefore(logEntry, logStream.firstChild);
                
                if (logStream.children.length > 20) {
                    logStream.removeChild(logStream.lastChild);
                }
            }

            addDecision(decision) {
                const decisionLog = document.getElementById('decisionLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry log-info';
                entry.textContent = `[${new Date().toISOString().split('T')[1].split('.')[0]}] ${decision}`;
                
                decisionLog.insertBefore(entry, decisionLog.firstChild);
                
                if (decisionLog.children.length > 15) {
                    decisionLog.removeChild(decisionLog.lastChild);
                }
            }

            addReasoningStep(message, type = 'info') {
                const reasoningTrace = document.getElementById('reasoningTrace');
                const traceStatus = reasoningTrace.querySelector('.trace-status');
                
                // Remove the waiting message if it exists
                if (traceStatus && traceStatus.textContent === 'Waiting for anomaly detection...') {
                    traceStatus.remove();
                }
                
                const stepDiv = document.createElement('div');
                stepDiv.className = `trace-step ${type}`;
                stepDiv.innerHTML = message;
                reasoningTrace.appendChild(stepDiv);
                
                // Auto-scroll to bottom
                reasoningTrace.scrollTop = reasoningTrace.scrollHeight;
                
                // Keep only last 20 steps
                const steps = reasoningTrace.querySelectorAll('.trace-step');
                while (steps.length > 20) {
                    reasoningTrace.removeChild(steps[0]);
                }
            }

            clearReasoningTrace() {
                const reasoningTrace = document.getElementById('reasoningTrace');
                reasoningTrace.innerHTML = '<div class="trace-status">Starting new incident analysis...</div>';
            }

            async triggerReportAndPaging(anomaly) {
                try {
                    // Trigger report generation
                    const reportResponse = await fetch(`${this.apiBase}/test-report-generation`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (reportResponse.ok) {
                        const reportResult = await reportResponse.json();
                        if (reportResult.success) {
                            this.addDecision('üìß Report Generation: Critical SRE report sent successfully');
                        }
                    }
                    
                    // Trigger paging
                    const pagingResponse = await fetch(`${this.apiBase}/test-paging`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (pagingResponse.ok) {
                        const pagingResult = await pagingResponse.json();
                        if (pagingResult.success) {
                            this.addDecision('üìû Paging Agent: Critical alert sent to SRE on-call');
                        }
                    }
                } catch (error) {
                    console.error('Error triggering report and paging:', error);
                }
            }

            updateConnectionStatus(text, status) {
                const statusElement = document.getElementById('connectionStatus');
                const textElement = document.getElementById('connectionText');
                
                textElement.textContent = text;
                statusElement.className = `connection-status ${status}`;
            }

            toggleAutoRefresh() {
                this.autoRefresh = !this.autoRefresh;
                const btn = document.getElementById('autoRefreshBtn');
                btn.textContent = `Auto Refresh: ${this.autoRefresh ? 'ON' : 'OFF'}`;
                
                if (this.autoRefresh) {
                    this.startRealTimeUpdates();
                } else if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
            }

            clearLogs() {
                document.getElementById('logStream').innerHTML = '';
                document.getElementById('decisionLog').innerHTML = '';
            }

            async resetSystem() {
                try {
                    // Call the API to reset system
                    const response = await fetch(`${this.apiBase}/reset-system`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to reset system');
                    }
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Clear local state
                        this.activeAnomalies = [];
                        this.mitigationHistory = [];
                        
                        // Reset all agent states
                        this.activateAgent('anomalyDetector', 'Idle');
                        this.activateAgent('ragAgent', 'Idle');
                        this.activateAgent('mitigationAgent', 'Idle');
                        this.activateAgent('advancedLLM', 'Idle');
                        this.activateAgent('pagingAgent', 'Idle');
                        
                        // Clear displays
                        document.getElementById('ragThoughts').style.display = 'none';
                        document.getElementById('validationResults').style.display = 'none';
                        document.getElementById('ragKnowledge').innerHTML = '';
                        document.getElementById('mitigationActions').innerHTML = '';
                        this.clearReasoningTrace();
                        
                        // Refresh data to show updated metrics
                        setTimeout(() => this.refreshData(), 500);
                        
                        this.addLog('INFO', 'üîÑ System reset to normal operation');
                        this.addDecision('System: All anomalies cleared, returning to normal state');
                    } else {
                        console.error('Failed to reset system:', result.error);
                    }
                } catch (error) {
                    console.error('Error resetting system:', error);
                }
            }
        }

        // Initialize the dashboard
        const dashboard = new SREDashboard();

        // Global functions for buttons
        async function refreshData() {
            await dashboard.refreshData();
        }

        function clearLogs() {
            dashboard.clearLogs();
        }

        function toggleAutoRefresh() {
            dashboard.toggleAutoRefresh();
        }

        async function triggerAnomaly(anomalyType) {
            await dashboard.triggerAnomaly(anomalyType);
        }

        async function resetSystem() {
            await dashboard.resetSystem();
        }



        // Auto-start for demo purposes
        window.addEventListener('load', () => {
            console.log('SRE Agent Dashboard loaded - ready for anomaly simulation...');
        });
    </script>
</body>
</html>
